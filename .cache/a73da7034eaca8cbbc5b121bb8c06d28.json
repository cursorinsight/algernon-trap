{"dependencies":[],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar idleTimer, epochTs, _lastTs;\n\nvar State = function () {\n  function State(window, transport, idleTimeout) {\n    _classCallCheck(this, State);\n\n    this.window = window, this.transport = transport, this.idleTimeout = idleTimeout;\n\n    this.getDT = this.getDT.bind(this);\n    this.idleHandler = this.idleHandler.bind(this);\n\n    if (idleTimeout !== 0) {\n      this.idleHandler();\n    }\n  }\n\n  _createClass(State, [{\n    key: \"idleHandler\",\n    value: function idleHandler() {\n      this.transport.send();\n      idleTimer = null;\n    }\n\n    /*\r\n     * Returns a stable time difference (between events, even if event does not\r\n     * support event.timeStamp).\r\n     *\r\n     * Examples:\r\n     *                  0 -- firefox window resize / scroll\r\n     *          161262400 -- firefox mouse move\r\n     *         1409096136 -- timestamp sec\r\n     *         2000000000 -- timestamp sec boundary\r\n     *      1409095770713 -- chrome all\r\n     *      1409096838717 -- firefox (new Date()).getTime()\r\n     *   1000000000000000 -- timestamp micro boundary\r\n     *   1409096424364149 -- firefox custom event\r\n     */\n\n  }, {\n    key: \"getDT\",\n    value: function getDT(event, bits) {\n\n      var round = Math.round,\n          currentTs = event && typeof event.timeStamp === \"number\" && event.timeStamp || new Date().getTime(),\n          dT;\n\n      if (idleTimer) {\n        this.window.clearTimeout(idleTimer);\n        idleTimer = null;\n      }\n\n      if (currentTs > 1000000000000000) {\n        // (microseconds) in Firefox, special events\n        currentTs = round(currentTs / 1000);\n      }\n\n      if (currentTs < 2000000000) {\n        // (milliseconds) it's Firefox; take care\n        if (!epochTs) {\n          epochTs = new Date().getTime() - currentTs;\n        }\n        if (_lastTs) {\n          dT = currentTs + epochTs - _lastTs;\n        }\n        _lastTs = currentTs + epochTs;\n      } else {\n        // (milliseconds) everything else\n        if (_lastTs) {\n          dT = currentTs - _lastTs;\n        }\n        _lastTs = currentTs;\n      }\n\n      // var dT1 = dT;\n\n      if (dT === undefined) {\n        return 0;\n      }\n\n      if (this.idleTimeout !== 0) {\n        idleTimer = this.window.setTimeout(this.idleHandler, this.idleTimeout);\n      }\n\n      if (bits) {\n        var max = (1 << bits) - 1;\n        dT = dT > max ? max : dT;\n      }\n\n      // TODO we should correct sync (when dT < 0)\n      // if (dT < 0) { // we can correct sync\n      //   epochTs = epochTs + dT;\n      //   lastTs  = lastTs + dT;\n      //   dT = 0;\n      // }\n      // console.log(dT1, dT, dT1 !== dT && \"-----------------------------------------\");\n\n      return dT;\n    }\n  }, {\n    key: \"lastTs\",\n    value: function lastTs() {\n      return _lastTs;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      // noop\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      _lastTs = null;\n    }\n  }]);\n\n  return State;\n}();\n\n;\n\nexports.default = State;"},"hash":"cf0487814e79b24370078d41bdb22840"}